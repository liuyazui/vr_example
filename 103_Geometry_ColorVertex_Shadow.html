<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>模型顶点着色和阴影</title>
    <script src="./three/three.js"></script>
    <script src="./js/controls/OrbitControls.js"></script>
</head>

<body>
    <script>

        //import * as THREE from './three.module.js';

        let camera, scene, renderer;
        let mesh;

        init();
        render();

        function init() {

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 400;

            scene = new THREE.Scene();

            const light = new THREE.DirectionalLight(0xffffff);
            light.position.set(0, 0, 1);
            scene.add(light);

            //阴影 创建一个阴影投射区域
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;

            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
            gradient.addColorStop(0.1, 'rgba(210,210,210,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,1)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            const shadowTexture = new THREE.CanvasTexture(canvas);

            const shadowMaterial = new THREE.MeshBasicMaterial({ map: shadowTexture });
            const shadowGeo = new THREE.PlaneGeometry(300, 300, 1, 1);

            let shadowMesh;

            shadowMesh = new THREE.Mesh(shadowGeo, shadowMaterial);
            shadowMesh.position.y = - 250;
            shadowMesh.rotation.x = - Math.PI / 2;
            scene.add(shadowMesh);
            //阴影

            //创建几何体
            const radius = 200;

            const geometry1 = new THREE.IcosahedronGeometry(radius, 1);

            const count = geometry1.attributes.position.count;//几何体所有顶点的数目
            geometry1.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));

            const geometry2 = geometry1.clone();
            const geometry3 = geometry1.clone();

            //根据几何体的位置设置每个顶点的颜色
            const color = new THREE.Color();
            const positions1 = geometry1.attributes.position;
            const positions2 = geometry2.attributes.position;
            const positions3 = geometry3.attributes.position;
            const colors1 = geometry1.attributes.color;
            const colors2 = geometry2.attributes.color;
            const colors3 = geometry3.attributes.color;
            for (let i = 0; i < count; i++) {

                color.setHSL((positions1.getY(i) / radius + 1) / 2, 1.0, 0.5);//根据顶点位置设定HSL颜色
                colors1.setXYZ(i, color.r, color.g, color.b);//从HSL颜色转换为RGB颜色，并赋予每个对应的顶点

                color.setHSL(0, (positions2.getY(i) / radius + 1) / 2, 0.5);
                colors2.setXYZ(i, color.r, color.g, color.b);

                color.setRGB(1, 0.8 - (positions3.getY(i) / radius + 1) / 2, 0);
                colors3.setXYZ(i, color.r, color.g, color.b);

            }
            const material = new THREE.MeshPhongMaterial({//Phong光照模型
                color: 0xffffff,//默认光照
                flatShading: true,//平滑着色
                vertexColors: true,//采用顶点着色，模型颜色使用每个顶点的颜色
                shininess: 0
            });

            const wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true });
            let mesh = new THREE.Mesh(geometry1, material);
            let wireframe = new THREE.Mesh(geometry1, wireframeMaterial);
            mesh.add(wireframe);
            //mesh.position.x = - 400;
            mesh.rotation.x = - 1.87;
            scene.add(mesh);
            //创建几何体

            //添加场景坐标轴
            var axisHelper = new THREE.AxisHelper(250);
            scene.add(axisHelper);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            document.body.appendChild(renderer.domElement);

            //

            window.addEventListener('resize', onWindowResize);


            var controls = new THREE.OrbitControls(camera, renderer.domElement);//创建控件对象
            controls.addEventListener('change', render);//监听鼠标、键盘事件
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }
        function render() {
            requestAnimationFrame(render);

            renderer.render(scene, camera);//执行渲染操作

        }
    </script>
</body>

</html>